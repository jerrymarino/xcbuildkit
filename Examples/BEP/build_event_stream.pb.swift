// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration type characterizing the size of a test, as specified by the
/// test rule.
public enum BuildEventStream_TestSize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case small // = 1
  case medium // = 2
  case large // = 3
  case enormous // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .small
    case 2: self = .medium
    case 3: self = .large
    case 4: self = .enormous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .small: return 1
    case .medium: return 2
    case .large: return 3
    case .enormous: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestSize] = [
    .unknown,
    .small,
    .medium,
    .large,
    .enormous,
  ]
}

#endif  // swift(>=4.2)

public enum BuildEventStream_TestStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noStatus // = 0
  case passed // = 1
  case flaky // = 2
  case timeout // = 3
  case failed // = 4
  case incomplete // = 5
  case remoteFailure // = 6
  case failedToBuild // = 7
  case toolHaltedBeforeTesting // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStatus
    case 1: self = .passed
    case 2: self = .flaky
    case 3: self = .timeout
    case 4: self = .failed
    case 5: self = .incomplete
    case 6: self = .remoteFailure
    case 7: self = .failedToBuild
    case 8: self = .toolHaltedBeforeTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStatus: return 0
    case .passed: return 1
    case .flaky: return 2
    case .timeout: return 3
    case .failed: return 4
    case .incomplete: return 5
    case .remoteFailure: return 6
    case .failedToBuild: return 7
    case .toolHaltedBeforeTesting: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestStatus] = [
    .noStatus,
    .passed,
    .flaky,
    .timeout,
    .failed,
    .incomplete,
    .remoteFailure,
    .failedToBuild,
    .toolHaltedBeforeTesting,
  ]
}

#endif  // swift(>=4.2)

/// Identifier for a build event. It is deliberately structured to also provide
/// information about which build target etc the event is related to.
///
/// Events are chained via the event id as follows: each event has an id and a
/// set of ids of children events such that apart from the initial event each
/// event has an id that is mentioned as child id in an earlier event and a build
/// invocation is complete if and only if all direct and indirect children of the
/// initial event have been posted.
public struct BuildEventStream_BuildEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var unknown: BuildEventStream_BuildEventId.UnknownBuildEventId {
    get {
      if case .unknown(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnknownBuildEventId()
    }
    set {_uniqueStorage()._id = .unknown(newValue)}
  }

  public var progress: BuildEventStream_BuildEventId.ProgressId {
    get {
      if case .progress(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ProgressId()
    }
    set {_uniqueStorage()._id = .progress(newValue)}
  }

  public var started: BuildEventStream_BuildEventId.BuildStartedId {
    get {
      if case .started(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildStartedId()
    }
    set {_uniqueStorage()._id = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_BuildEventId.UnstructuredCommandLineId {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnstructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: BuildEventStream_BuildEventId.StructuredCommandLineId {
    get {
      if case .structuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.StructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .structuredCommandLine(newValue)}
  }

  public var workspaceStatus: BuildEventStream_BuildEventId.WorkspaceStatusId {
    get {
      if case .workspaceStatus(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.WorkspaceStatusId()
    }
    set {_uniqueStorage()._id = .workspaceStatus(newValue)}
  }

  public var optionsParsed: BuildEventStream_BuildEventId.OptionsParsedId {
    get {
      if case .optionsParsed(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.OptionsParsedId()
    }
    set {_uniqueStorage()._id = .optionsParsed(newValue)}
  }

  public var fetch: BuildEventStream_BuildEventId.FetchId {
    get {
      if case .fetch(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.FetchId()
    }
    set {_uniqueStorage()._id = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {
      if case .configuration(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfigurationId()
    }
    set {_uniqueStorage()._id = .configuration(newValue)}
  }

  public var targetConfigured: BuildEventStream_BuildEventId.TargetConfiguredId {
    get {
      if case .targetConfigured(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetConfiguredId()
    }
    set {_uniqueStorage()._id = .targetConfigured(newValue)}
  }

  public var pattern: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .pattern(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .pattern(newValue)}
  }

  public var patternSkipped: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .patternSkipped(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .patternSkipped(newValue)}
  }

  public var namedSet: BuildEventStream_BuildEventId.NamedSetOfFilesId {
    get {
      if case .namedSet(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.NamedSetOfFilesId()
    }
    set {_uniqueStorage()._id = .namedSet(newValue)}
  }

  public var targetCompleted: BuildEventStream_BuildEventId.TargetCompletedId {
    get {
      if case .targetCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetCompletedId()
    }
    set {_uniqueStorage()._id = .targetCompleted(newValue)}
  }

  public var actionCompleted: BuildEventStream_BuildEventId.ActionCompletedId {
    get {
      if case .actionCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ActionCompletedId()
    }
    set {_uniqueStorage()._id = .actionCompleted(newValue)}
  }

  public var unconfiguredLabel: BuildEventStream_BuildEventId.UnconfiguredLabelId {
    get {
      if case .unconfiguredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnconfiguredLabelId()
    }
    set {_uniqueStorage()._id = .unconfiguredLabel(newValue)}
  }

  public var configuredLabel: BuildEventStream_BuildEventId.ConfiguredLabelId {
    get {
      if case .configuredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfiguredLabelId()
    }
    set {_uniqueStorage()._id = .configuredLabel(newValue)}
  }

  public var testResult: BuildEventStream_BuildEventId.TestResultId {
    get {
      if case .testResult(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestResultId()
    }
    set {_uniqueStorage()._id = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_BuildEventId.TestSummaryId {
    get {
      if case .testSummary(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestSummaryId()
    }
    set {_uniqueStorage()._id = .testSummary(newValue)}
  }

  public var buildFinished: BuildEventStream_BuildEventId.BuildFinishedId {
    get {
      if case .buildFinished(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildFinishedId()
    }
    set {_uniqueStorage()._id = .buildFinished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildEventId.BuildToolLogsId {
    get {
      if case .buildToolLogs(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildToolLogsId()
    }
    set {_uniqueStorage()._id = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildEventId.BuildMetricsId {
    get {
      if case .buildMetrics(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildMetricsId()
    }
    set {_uniqueStorage()._id = .buildMetrics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    case unknown(BuildEventStream_BuildEventId.UnknownBuildEventId)
    case progress(BuildEventStream_BuildEventId.ProgressId)
    case started(BuildEventStream_BuildEventId.BuildStartedId)
    case unstructuredCommandLine(BuildEventStream_BuildEventId.UnstructuredCommandLineId)
    case structuredCommandLine(BuildEventStream_BuildEventId.StructuredCommandLineId)
    case workspaceStatus(BuildEventStream_BuildEventId.WorkspaceStatusId)
    case optionsParsed(BuildEventStream_BuildEventId.OptionsParsedId)
    case fetch(BuildEventStream_BuildEventId.FetchId)
    case configuration(BuildEventStream_BuildEventId.ConfigurationId)
    case targetConfigured(BuildEventStream_BuildEventId.TargetConfiguredId)
    case pattern(BuildEventStream_BuildEventId.PatternExpandedId)
    case patternSkipped(BuildEventStream_BuildEventId.PatternExpandedId)
    case namedSet(BuildEventStream_BuildEventId.NamedSetOfFilesId)
    case targetCompleted(BuildEventStream_BuildEventId.TargetCompletedId)
    case actionCompleted(BuildEventStream_BuildEventId.ActionCompletedId)
    case unconfiguredLabel(BuildEventStream_BuildEventId.UnconfiguredLabelId)
    case configuredLabel(BuildEventStream_BuildEventId.ConfiguredLabelId)
    case testResult(BuildEventStream_BuildEventId.TestResultId)
    case testSummary(BuildEventStream_BuildEventId.TestSummaryId)
    case buildFinished(BuildEventStream_BuildEventId.BuildFinishedId)
    case buildToolLogs(BuildEventStream_BuildEventId.BuildToolLogsId)
    case buildMetrics(BuildEventStream_BuildEventId.BuildMetricsId)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEventId.OneOf_ID, rhs: BuildEventStream_BuildEventId.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.unknown(let l), .unknown(let r)): return l == r
      case (.progress(let l), .progress(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.targetConfigured(let l), .targetConfigured(let r)): return l == r
      case (.pattern(let l), .pattern(let r)): return l == r
      case (.patternSkipped(let l), .patternSkipped(let r)): return l == r
      case (.namedSet(let l), .namedSet(let r)): return l == r
      case (.targetCompleted(let l), .targetCompleted(let r)): return l == r
      case (.actionCompleted(let l), .actionCompleted(let r)): return l == r
      case (.unconfiguredLabel(let l), .unconfiguredLabel(let r)): return l == r
      case (.configuredLabel(let l), .configuredLabel(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.buildFinished(let l), .buildFinished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Generic identifier for a build event. This is the default type of
  /// BuildEventId, but should not be used outside testing; nevertheless,
  /// tools should handle build events with this kind of id gracefully.
  public struct UnknownBuildEventId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting progress. Those events are also used to
  /// chain in events that come early.
  public struct ProgressId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique identifier. No assumption should be made about how the ids are
    /// assigned; the only meaningful operation on this field is test for
    /// equality.
    public var opaqueCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the beginning of a build; this will
  /// normally be the first event.
  public struct BuildStartedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event indicating the original commandline received by
  /// the bazel server.
  public struct UnstructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event describing the commandline received by Bazel.
  public struct StructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A title for this command line value, as there may be multiple.
    /// For example, a single invocation may wish to report both the literal and
    /// canonical command lines, and this label would be used to differentiate
    /// between both versions.
    public var commandLineLabel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the workspace status.
  public struct WorkspaceStatusId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event reporting on the options included in the command
  /// line, both explicitly and implicitly.
  public struct OptionsParsedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting that an external resource was fetched
  /// from.
  public struct FetchId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The external resource that was fetched from.
    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target pattern has been expanded
  /// further.
  /// Messages of this shape are also used to describe parts of a pattern that
  /// have been skipped for some reason, if the actual expansion was still
  /// carried out (e.g., if keep_going is set). In this case, the
  /// pattern_skipped choice in the id field is to be made.
  public struct PatternExpandedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pattern: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target has been expanded by
  /// identifying for which configurations it should be build.
  public struct TargetConfiguredId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// If not empty, the id refers to the expansion of the target for a given
    /// aspect.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a named set of files (usually artifacts)
  /// to be referred to in later messages.
  public struct NamedSetOfFilesId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the file set; this is an opaque string valid only for the
    /// particular instance of the event stream.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a configuration.
  public struct ConfigurationId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the configuration; users of the protocol should not make
    /// any assumptions about it having any structure, or equality of the
    /// identifier between different streams.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target was built completely; this
  /// does not include running the test if the target is a test target.
  public struct TargetCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    /// The configuration for which the target was built.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    /// If not empty, the id refers to the completion of the target for a given
    /// aspect.
    public var aspect: String {
      get {return _storage._aspect}
      set {_uniqueStorage()._aspect = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting that an action was completed (not all
  /// actions are reported, only the ones that can be considered important;
  /// this includes all failed actions).
  public struct ActionCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var primaryOutput: String {
      get {return _storage._primaryOutput}
      set {_uniqueStorage()._primaryOutput = newValue}
    }

    /// Optional, the label of the owner of the action, for reference.
    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    /// Optional, the id of the configuration of the action owner.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting an event associated with an unconfigured
  /// label. Usually, this indicates a failure due to a missing input file. In
  /// any case, it will report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier. The
  /// purpose of those events is to serve as the root cause of a failed target.
  public struct UnconfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting an event associated with a configured
  /// label, usually a visibility error. In any case, an event with such an
  /// id will always report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier.
  public struct ConfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting on an individual test run. The label
  /// identifies the test that is reported about, the remaining fields are
  /// in such a way as to uniquely identify the action within a build. In fact,
  /// attempts for the same test, run, shard triple are counted sequentially,
  /// starting with 1.
  public struct TestResultId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var run: Int32 {
      get {return _storage._run}
      set {_uniqueStorage()._run = newValue}
    }

    public var shard: Int32 {
      get {return _storage._shard}
      set {_uniqueStorage()._shard = newValue}
    }

    public var attempt: Int32 {
      get {return _storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of an event reporting the summary of a test.
  public struct TestSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Identifier of the BuildFinished event, indicating the end of a build.
  public struct BuildFinishedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing additional logs/statistics after
  /// completion of the build.
  public struct BuildToolLogsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing build metrics after completion
  /// of the build.
  public struct BuildMetricsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of an event summarizing the progress of the build so far. Those
/// events are also used to be parents of events where the more logical parent
/// event cannot be posted yet as the needed information is not yet complete.
public struct BuildEventStream_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next chunk of stdout that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stdout: String = String()

  /// The next chunk of stderr that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stderr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event indicating that an expected event will not come, as
/// the build is aborted prematurely for some reason.
public struct BuildEventStream_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: BuildEventStream_Aborted.AbortReason = .unknown

  /// A human readable description with more details about there reason, where
  /// available and useful.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AbortReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The user requested the build to be aborted (e.g., by hitting Ctl-C).
    case userInterrupted // = 1

    /// The user requested that no analysis be performed.
    case noAnalyze // = 8

    /// The user requested that no build be carried out.
    case noBuild // = 9

    /// The build or target was aborted as a timeout was exceeded.
    case timeOut // = 2

    /// The build or target was aborted as some remote environment (e.g., for
    /// remote execution of actions) was not available in the expected way.
    case remoteEnvironmentFailure // = 3

    /// Failure due to reasons entirely internal to the build tool, e.g.,
    /// running out of memory.
    case `internal` // = 4

    /// A Failure occurred in the loading phase of a target.
    case loadingFailure // = 5

    /// A Failure occurred in the analysis phase of a target.
    case analysisFailure // = 6

    /// Target build was skipped (e.g. due to incompatible CPU constraints).
    case skipped // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userInterrupted
      case 2: self = .timeOut
      case 3: self = .remoteEnvironmentFailure
      case 4: self = .internal
      case 5: self = .loadingFailure
      case 6: self = .analysisFailure
      case 7: self = .skipped
      case 8: self = .noAnalyze
      case 9: self = .noBuild
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userInterrupted: return 1
      case .timeOut: return 2
      case .remoteEnvironmentFailure: return 3
      case .internal: return 4
      case .loadingFailure: return 5
      case .analysisFailure: return 6
      case .skipped: return 7
      case .noAnalyze: return 8
      case .noBuild: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_Aborted.AbortReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_Aborted.AbortReason] = [
    .unknown,
    .userInterrupted,
    .noAnalyze,
    .noBuild,
    .timeOut,
    .remoteEnvironmentFailure,
    .internal,
    .loadingFailure,
    .analysisFailure,
    .skipped,
  ]
}

#endif  // swift(>=4.2)

/// Payload of an event indicating the beginning of a new build. Usually, events
/// of those type start a new build-event stream. The target pattern requested
/// to be build is contained in one of the announced child events; it is an
/// invariant that precisely one of the announced child events has a non-empty
/// target pattern.
public struct BuildEventStream_BuildStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  /// Start of the build in ms since the epoch.
  /// TODO(buchgr): Use google.protobuf.TimeStamp once bazel's protoc supports
  /// it.
  public var startTimeMillis: Int64 = 0

  /// Version of the build tool that is running.
  public var buildToolVersion: String = String()

  /// A human-readable description of all the non-default option settings
  public var optionsDescription: String = String()

  /// The name of the command that the user invoked.
  public var command: String = String()

  /// The working directory from which the build tool was invoked.
  public var workingDirectory: String = String()

  /// The directory of the workspace.
  public var workspaceDirectory: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the command-line of the invocation as
/// originally received by the server. Note that this is not the command-line
/// given by the user, as the client adds information about the invocation,
/// like name and relevant entries of rc-files and client environment variables.
/// However, it does contain enough information to reproduce the build
/// invocation.
public struct BuildEventStream_UnstructuredCommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting on the parsed options, grouped in various ways.
public struct BuildEventStream_OptionsParsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startupOptions: [String] {
    get {return _storage._startupOptions}
    set {_uniqueStorage()._startupOptions = newValue}
  }

  public var explicitStartupOptions: [String] {
    get {return _storage._explicitStartupOptions}
    set {_uniqueStorage()._explicitStartupOptions = newValue}
  }

  public var cmdLine: [String] {
    get {return _storage._cmdLine}
    set {_uniqueStorage()._cmdLine = newValue}
  }

  public var explicitCmdLine: [String] {
    get {return _storage._explicitCmdLine}
    set {_uniqueStorage()._explicitCmdLine = newValue}
  }

  public var invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy {
    get {return _storage._invocationPolicy ?? Blaze_InvocationPolicy_InvocationPolicy()}
    set {_uniqueStorage()._invocationPolicy = newValue}
  }
  /// Returns true if `invocationPolicy` has been explicitly set.
  public var hasInvocationPolicy: Bool {return _storage._invocationPolicy != nil}
  /// Clears the value of `invocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationPolicy() {_uniqueStorage()._invocationPolicy = nil}

  public var toolTag: String {
    get {return _storage._toolTag}
    set {_uniqueStorage()._toolTag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of an event indicating that an external resource was fetched. This
/// event will only occur in streams where an actual fetch happened, not in ones
/// where a cached copy of the entity to be fetched was used.
public struct BuildEventStream_Fetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the workspace status. Key-value pairs can be
/// provided by specifying the workspace_status_command to an executable that
/// returns one key-value pair per line of output (key and value separated by a
/// space).
public struct BuildEventStream_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [BuildEventStream_WorkspaceStatus.Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event reporting details of a given configuration.
public struct BuildEventStream_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mnemonic: String = String()

  public var platformName: String = String()

  public var cpu: String = String()

  public var makeVariable: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the expansion of a target pattern.
/// The main information is in the chaining part: the id will contain the
/// target pattern that was expanded and the children id will contain the
/// target or target pattern it was expanded to.
public struct BuildEventStream_PatternExpanded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating that the configurations for a target have
/// been identified. As with pattern expansion the main information is in the
/// chaining part: the id will contain the target that was configured and the
/// children id will contain the configured targets it was configured to.
public struct BuildEventStream_TargetConfigured {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// List of all tags associated with this target (for all possible
  /// configurations).
  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// identifier indicating the nature of the file (e.g., "stdout", "stderr")
  public var name: String = String()

  public var file: BuildEventStream_File.OneOf_File? = nil

  /// A location where the contents of the file can be found. The string is
  /// encoded according to RFC2396.
  public var uri: String {
    get {
      if case .uri(let v)? = file {return v}
      return String()
    }
    set {file = .uri(newValue)}
  }

  /// The contents of the file, if they are guaranteed to be short.
  public var contents: Data {
    get {
      if case .contents(let v)? = file {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {file = .contents(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_File: Equatable {
    /// A location where the contents of the file can be found. The string is
    /// encoded according to RFC2396.
    case uri(String)
    /// The contents of the file, if they are guaranteed to be short.
    case contents(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_File.OneOf_File, rhs: BuildEventStream_File.OneOf_File) -> Bool {
      switch (lhs, rhs) {
      case (.uri(let l), .uri(let r)): return l == r
      case (.contents(let l), .contents(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Payload of a message to describe a set of files, usually build artifacts, to
/// be referred to later by their name. In this way, files that occur identically
/// as outputs of several targets have to be named only once.
public struct BuildEventStream_NamedSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Files that belong to this named set of files.
  public var files: [BuildEventStream_File] = []

  /// Other named sets whose members also belong to this set.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of an action. The main purpose
/// of posting those events is to provide details on the root cause for a target
/// failing; however, consumers of the build-event protocol must not assume
/// that only failed actions are posted.
public struct BuildEventStream_ActionExecuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// The mnemonic of the action that was executed
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The exit code of the action, if it is available.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Location where to find the standard output of the action
  /// (e.g., a file path).
  public var stdout: BuildEventStream_File {
    get {return _storage._stdout ?? BuildEventStream_File()}
    set {_uniqueStorage()._stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  public var hasStdout: Bool {return _storage._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  public mutating func clearStdout() {_uniqueStorage()._stdout = nil}

  /// Location where to find the standard error of the action
  /// (e.g., a file path).
  public var stderr: BuildEventStream_File {
    get {return _storage._stderr ?? BuildEventStream_File()}
    set {_uniqueStorage()._stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return _storage._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {_uniqueStorage()._stderr = nil}

  /// Deprecated. This field is now present on ActionCompletedId.
  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  /// Deprecated. This field is now present on ActionCompletedId.
  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  /// Primary output; only provided for successful actions.
  public var primaryOutput: BuildEventStream_File {
    get {return _storage._primaryOutput ?? BuildEventStream_File()}
    set {_uniqueStorage()._primaryOutput = newValue}
  }
  /// Returns true if `primaryOutput` has been explicitly set.
  public var hasPrimaryOutput: Bool {return _storage._primaryOutput != nil}
  /// Clears the value of `primaryOutput`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryOutput() {_uniqueStorage()._primaryOutput = nil}

  /// The command-line of the action, if the action is a command.
  public var commandLine: [String] {
    get {return _storage._commandLine}
    set {_uniqueStorage()._commandLine = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Collection of all output files belonging to that output group.
public struct BuildEventStream_OutputGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the output group
  public var name: String = String()

  /// List of file sets that belong to this output group as well.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of a target. The target is
/// specified in the id. If the target failed the root causes are provided as
/// children events.
public struct BuildEventStream_TargetComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  /// Deprecated: use the target_kind field in TargetConfigured instead.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  /// Deprecated: use the test_size field in TargetConfigured instead.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// The output files are arranged by their output group. If an output file
  /// is part of multiple output groups, it appears once in each output
  /// group.
  public var outputGroup: [BuildEventStream_OutputGroup] = []

  /// Temporarily, also report the important outputs directly. This is only to
  /// allow existing clients help transition to the deduplicated representation;
  /// new clients should not use it.
  public var importantOutput: [BuildEventStream_File] = []

  /// List of tags associated with this configured target.
  public var tag: [String] = []

  /// The timeout specified for test actions under this configured target.
  public var testTimeoutSeconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload on events reporting about individual test action.
public struct BuildEventStream_TestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of this test.
  public var status: BuildEventStream_TestStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Additional details about the status of the test. This is intended for
  /// user display and must not be parsed.
  public var statusDetails: String {
    get {return _storage._statusDetails}
    set {_uniqueStorage()._statusDetails = newValue}
  }

  /// True, if the reported attempt is taken from the tool's local cache.
  public var cachedLocally: Bool {
    get {return _storage._cachedLocally}
    set {_uniqueStorage()._cachedLocally = newValue}
  }

  /// Time in milliseconds since the epoch at which the test attempt was started.
  /// Note: for cached test results, this is time can be before the start of the
  /// build.
  public var testAttemptStartMillisEpoch: Int64 {
    get {return _storage._testAttemptStartMillisEpoch}
    set {_uniqueStorage()._testAttemptStartMillisEpoch = newValue}
  }

  /// Time the test took to run. For locally cached results, this is the time
  /// the cached invocation took when it was invoked.
  public var testAttemptDurationMillis: Int64 {
    get {return _storage._testAttemptDurationMillis}
    set {_uniqueStorage()._testAttemptDurationMillis = newValue}
  }

  /// Files (logs, test.xml, undeclared outputs, etc) generated by that test
  /// action.
  public var testActionOutput: [BuildEventStream_File] {
    get {return _storage._testActionOutput}
    set {_uniqueStorage()._testActionOutput = newValue}
  }

  /// Warnings generated by that test action.
  public var warning: [String] {
    get {return _storage._warning}
    set {_uniqueStorage()._warning = newValue}
  }

  public var executionInfo: BuildEventStream_TestResult.ExecutionInfo {
    get {return _storage._executionInfo ?? BuildEventStream_TestResult.ExecutionInfo()}
    set {_uniqueStorage()._executionInfo = newValue}
  }
  /// Returns true if `executionInfo` has been explicitly set.
  public var hasExecutionInfo: Bool {return _storage._executionInfo != nil}
  /// Clears the value of `executionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionInfo() {_uniqueStorage()._executionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message providing optional meta data on the execution of the test action,
  /// if available.
  public struct ExecutionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated, use TargetComplete.test_timeout_seconds instead.
    public var timeoutSeconds: Int32 {
      get {return _storage._timeoutSeconds}
      set {_uniqueStorage()._timeoutSeconds = newValue}
    }

    /// Name of the strategy to execute this test action (e.g., "local",
    /// "remote")
    public var strategy: String {
      get {return _storage._strategy}
      set {_uniqueStorage()._strategy = newValue}
    }

    /// True, if the reported attempt was a cache hit in a remote cache.
    public var cachedRemotely: Bool {
      get {return _storage._cachedRemotely}
      set {_uniqueStorage()._cachedRemotely = newValue}
    }

    /// The exit code of the test action.
    public var exitCode: Int32 {
      get {return _storage._exitCode}
      set {_uniqueStorage()._exitCode = newValue}
    }

    /// The hostname of the machine where the test action was executed (in case
    /// of remote execution), if known.
    public var hostname: String {
      get {return _storage._hostname}
      set {_uniqueStorage()._hostname = newValue}
    }

    public var timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown {
      get {return _storage._timingBreakdown ?? BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown()}
      set {_uniqueStorage()._timingBreakdown = newValue}
    }
    /// Returns true if `timingBreakdown` has been explicitly set.
    public var hasTimingBreakdown: Bool {return _storage._timingBreakdown != nil}
    /// Clears the value of `timingBreakdown`. Subsequent reads from it will return its default value.
    public mutating func clearTimingBreakdown() {_uniqueStorage()._timingBreakdown = nil}

    public var resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] {
      get {return _storage._resourceUsage}
      set {_uniqueStorage()._resourceUsage = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents a hierarchical timing breakdown of an activity.
    /// The top level time should be the total time of the activity.
    /// Invariant: time_millis >= sum of time_millis of all direct children.
    public struct TimingBreakdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var child: [BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown] = []

      public var name: String = String()

      public var timeMillis: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct ResourceUsage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of the event summarizing a test.
/// TODO(aehlig): extend event with additional information as soon as we known
/// which additional information we need for test summaries.
public struct BuildEventStream_TestSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wrapper around BlazeTestStatus to support importing that enum to proto3.
  /// Overall status of test, accumulated over all runs, shards, and attempts.
  public var overallStatus: BuildEventStream_TestStatus = .noStatus

  /// Total number of runs
  public var totalRunCount: Int32 = 0

  /// Path to logs of passed runs.
  public var passed: [BuildEventStream_File] = []

  /// Path to logs of failed runs;
  public var failed: [BuildEventStream_File] = []

  /// Total number of cached test actions
  public var totalNumCached: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event indicating the end of a build.
public struct BuildEventStream_BuildFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the build succeeded or failed.
  public var overallSuccess: Bool {
    get {return _storage._overallSuccess}
    set {_uniqueStorage()._overallSuccess = newValue}
  }

  /// The overall status of the build. A build was successful iff
  /// ExitCode.code equals 0.
  public var exitCode: BuildEventStream_BuildFinished.ExitCode {
    get {return _storage._exitCode ?? BuildEventStream_BuildFinished.ExitCode()}
    set {_uniqueStorage()._exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return _storage._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {_uniqueStorage()._exitCode = nil}

  /// Time in milliseconds since the epoch.
  /// TODO(buchgr): Use google.protobuf.Timestamp once bazel's protoc supports
  /// it.
  public var finishTimeMillis: Int64 {
    get {return _storage._finishTimeMillis}
    set {_uniqueStorage()._finishTimeMillis = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exit code of a build. The possible values correspond to the predefined
  /// codes in bazel's lib.ExitCode class, as well as any custom exit code a
  /// module might define. The predefined exit codes are subject to change (but
  /// rarely do) and are not part of the public API.
  ///
  /// A build was successful iff ExitCode.code equals 0.
  public struct ExitCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the exit code.
    public var name: String = String()

    /// The exit code.
    public var code: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_BuildMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionSummary: BuildEventStream_BuildMetrics.ActionSummary {
    get {return _storage._actionSummary ?? BuildEventStream_BuildMetrics.ActionSummary()}
    set {_uniqueStorage()._actionSummary = newValue}
  }
  /// Returns true if `actionSummary` has been explicitly set.
  public var hasActionSummary: Bool {return _storage._actionSummary != nil}
  /// Clears the value of `actionSummary`. Subsequent reads from it will return its default value.
  public mutating func clearActionSummary() {_uniqueStorage()._actionSummary = nil}

  public var memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics {
    get {return _storage._memoryMetrics ?? BuildEventStream_BuildMetrics.MemoryMetrics()}
    set {_uniqueStorage()._memoryMetrics = newValue}
  }
  /// Returns true if `memoryMetrics` has been explicitly set.
  public var hasMemoryMetrics: Bool {return _storage._memoryMetrics != nil}
  /// Clears the value of `memoryMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearMemoryMetrics() {_uniqueStorage()._memoryMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ActionSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total number of actions created and registered during the build.
    /// This includes unused actions that were constructed but
    /// not executed during this build.
    public var actionsCreated: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MemoryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Size of the JVM heap post build in bytes. This is only collected if
    /// --bep_publish_used_heap_size_post_build is set,
    /// since it forces a full GC.
    public var usedHeapSizePostBuild: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Event providing additional statistics/logs after completion of the build.
public struct BuildEventStream_BuildToolLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: [BuildEventStream_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message describing a build event. Events will have an identifier that
/// is unique within a given build invocation; they also announce follow-up
/// events as children. More details, which are specific to the kind of event
/// that is observed, is provided in the payload. More options for the payload
/// might be added in the future.
public struct BuildEventStream_BuildEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId {
    get {return _storage._id ?? BuildEventStream_BuildEventId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var children: [BuildEventStream_BuildEventId] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var lastMessage: Bool {
    get {return _storage._lastMessage}
    set {_uniqueStorage()._lastMessage = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var progress: BuildEventStream_Progress {
    get {
      if case .progress(let v)? = _storage._payload {return v}
      return BuildEventStream_Progress()
    }
    set {_uniqueStorage()._payload = .progress(newValue)}
  }

  public var aborted: BuildEventStream_Aborted {
    get {
      if case .aborted(let v)? = _storage._payload {return v}
      return BuildEventStream_Aborted()
    }
    set {_uniqueStorage()._payload = .aborted(newValue)}
  }

  public var started: BuildEventStream_BuildStarted {
    get {
      if case .started(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildStarted()
    }
    set {_uniqueStorage()._payload = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_UnstructuredCommandLine {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._payload {return v}
      return BuildEventStream_UnstructuredCommandLine()
    }
    set {_uniqueStorage()._payload = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: CommandLine_CommandLine {
    get {
      if case .structuredCommandLine(let v)? = _storage._payload {return v}
      return CommandLine_CommandLine()
    }
    set {_uniqueStorage()._payload = .structuredCommandLine(newValue)}
  }

  public var optionsParsed: BuildEventStream_OptionsParsed {
    get {
      if case .optionsParsed(let v)? = _storage._payload {return v}
      return BuildEventStream_OptionsParsed()
    }
    set {_uniqueStorage()._payload = .optionsParsed(newValue)}
  }

  public var workspaceStatus: BuildEventStream_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceStatus()
    }
    set {_uniqueStorage()._payload = .workspaceStatus(newValue)}
  }

  public var fetch: BuildEventStream_Fetch {
    get {
      if case .fetch(let v)? = _storage._payload {return v}
      return BuildEventStream_Fetch()
    }
    set {_uniqueStorage()._payload = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_Configuration {
    get {
      if case .configuration(let v)? = _storage._payload {return v}
      return BuildEventStream_Configuration()
    }
    set {_uniqueStorage()._payload = .configuration(newValue)}
  }

  public var expanded: BuildEventStream_PatternExpanded {
    get {
      if case .expanded(let v)? = _storage._payload {return v}
      return BuildEventStream_PatternExpanded()
    }
    set {_uniqueStorage()._payload = .expanded(newValue)}
  }

  public var configured: BuildEventStream_TargetConfigured {
    get {
      if case .configured(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetConfigured()
    }
    set {_uniqueStorage()._payload = .configured(newValue)}
  }

  public var action: BuildEventStream_ActionExecuted {
    get {
      if case .action(let v)? = _storage._payload {return v}
      return BuildEventStream_ActionExecuted()
    }
    set {_uniqueStorage()._payload = .action(newValue)}
  }

  public var namedSetOfFiles: BuildEventStream_NamedSetOfFiles {
    get {
      if case .namedSetOfFiles(let v)? = _storage._payload {return v}
      return BuildEventStream_NamedSetOfFiles()
    }
    set {_uniqueStorage()._payload = .namedSetOfFiles(newValue)}
  }

  public var completed: BuildEventStream_TargetComplete {
    get {
      if case .completed(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetComplete()
    }
    set {_uniqueStorage()._payload = .completed(newValue)}
  }

  public var testResult: BuildEventStream_TestResult {
    get {
      if case .testResult(let v)? = _storage._payload {return v}
      return BuildEventStream_TestResult()
    }
    set {_uniqueStorage()._payload = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_TestSummary {
    get {
      if case .testSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TestSummary()
    }
    set {_uniqueStorage()._payload = .testSummary(newValue)}
  }

  public var finished: BuildEventStream_BuildFinished {
    get {
      if case .finished(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildFinished()
    }
    set {_uniqueStorage()._payload = .finished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildToolLogs {
    get {
      if case .buildToolLogs(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildToolLogs()
    }
    set {_uniqueStorage()._payload = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildMetrics {
    get {
      if case .buildMetrics(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetrics()
    }
    set {_uniqueStorage()._payload = .buildMetrics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case progress(BuildEventStream_Progress)
    case aborted(BuildEventStream_Aborted)
    case started(BuildEventStream_BuildStarted)
    case unstructuredCommandLine(BuildEventStream_UnstructuredCommandLine)
    case structuredCommandLine(CommandLine_CommandLine)
    case optionsParsed(BuildEventStream_OptionsParsed)
    case workspaceStatus(BuildEventStream_WorkspaceStatus)
    case fetch(BuildEventStream_Fetch)
    case configuration(BuildEventStream_Configuration)
    case expanded(BuildEventStream_PatternExpanded)
    case configured(BuildEventStream_TargetConfigured)
    case action(BuildEventStream_ActionExecuted)
    case namedSetOfFiles(BuildEventStream_NamedSetOfFiles)
    case completed(BuildEventStream_TargetComplete)
    case testResult(BuildEventStream_TestResult)
    case testSummary(BuildEventStream_TestSummary)
    case finished(BuildEventStream_BuildFinished)
    case buildToolLogs(BuildEventStream_BuildToolLogs)
    case buildMetrics(BuildEventStream_BuildMetrics)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEvent.OneOf_Payload, rhs: BuildEventStream_BuildEvent.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.progress(let l), .progress(let r)): return l == r
      case (.aborted(let l), .aborted(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.expanded(let l), .expanded(let r)): return l == r
      case (.configured(let l), .configured(let r)): return l == r
      case (.action(let l), .action(let r)): return l == r
      case (.namedSetOfFiles(let l), .namedSetOfFiles(let r)): return l == r
      case (.completed(let l), .completed(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.finished(let l), .finished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build_event_stream"

extension BuildEventStream_TestSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
    4: .same(proto: "ENORMOUS"),
  ]
}

extension BuildEventStream_TestStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STATUS"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FLAKY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "REMOTE_FAILURE"),
    7: .same(proto: "FAILED_TO_BUILD"),
    8: .same(proto: "TOOL_HALTED_BEFORE_TESTING"),
  ]
}

extension BuildEventStream_BuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "progress"),
    3: .same(proto: "started"),
    11: .standard(proto: "unstructured_command_line"),
    18: .standard(proto: "structured_command_line"),
    14: .standard(proto: "workspace_status"),
    12: .standard(proto: "options_parsed"),
    17: .same(proto: "fetch"),
    15: .same(proto: "configuration"),
    16: .standard(proto: "target_configured"),
    4: .same(proto: "pattern"),
    10: .standard(proto: "pattern_skipped"),
    13: .standard(proto: "named_set"),
    5: .standard(proto: "target_completed"),
    6: .standard(proto: "action_completed"),
    19: .standard(proto: "unconfigured_label"),
    21: .standard(proto: "configured_label"),
    8: .standard(proto: "test_result"),
    7: .standard(proto: "test_summary"),
    9: .standard(proto: "build_finished"),
    20: .standard(proto: "build_tool_logs"),
    22: .standard(proto: "build_metrics"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: BuildEventStream_BuildEventId.UnknownBuildEventId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unknown(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unknown(v)}
        case 2:
          var v: BuildEventStream_BuildEventId.ProgressId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .progress(v)}
        case 3:
          var v: BuildEventStream_BuildEventId.BuildStartedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .started(v)}
        case 4:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .pattern(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .pattern(v)}
        case 5:
          var v: BuildEventStream_BuildEventId.TargetCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetCompleted(v)}
        case 6:
          var v: BuildEventStream_BuildEventId.ActionCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .actionCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .actionCompleted(v)}
        case 7:
          var v: BuildEventStream_BuildEventId.TestSummaryId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testSummary(v)}
        case 8:
          var v: BuildEventStream_BuildEventId.TestResultId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testResult(v)}
        case 9:
          var v: BuildEventStream_BuildEventId.BuildFinishedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildFinished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildFinished(v)}
        case 10:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .patternSkipped(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .patternSkipped(v)}
        case 11:
          var v: BuildEventStream_BuildEventId.UnstructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unstructuredCommandLine(v)}
        case 12:
          var v: BuildEventStream_BuildEventId.OptionsParsedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .optionsParsed(v)}
        case 13:
          var v: BuildEventStream_BuildEventId.NamedSetOfFilesId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .namedSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .namedSet(v)}
        case 14:
          var v: BuildEventStream_BuildEventId.WorkspaceStatusId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .workspaceStatus(v)}
        case 15:
          var v: BuildEventStream_BuildEventId.ConfigurationId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuration(v)}
        case 16:
          var v: BuildEventStream_BuildEventId.TargetConfiguredId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetConfigured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetConfigured(v)}
        case 17:
          var v: BuildEventStream_BuildEventId.FetchId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .fetch(v)}
        case 18:
          var v: BuildEventStream_BuildEventId.StructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .structuredCommandLine(v)}
        case 19:
          var v: BuildEventStream_BuildEventId.UnconfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unconfiguredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unconfiguredLabel(v)}
        case 20:
          var v: BuildEventStream_BuildEventId.BuildToolLogsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildToolLogs(v)}
        case 21:
          var v: BuildEventStream_BuildEventId.ConfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuredLabel(v)}
        case 22:
          var v: BuildEventStream_BuildEventId.BuildMetricsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildMetrics(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._id {
      case .unknown(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .pattern(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .targetCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .actionCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .buildFinished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .patternSkipped(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .namedSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .targetConfigured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .unconfiguredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .configuredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId, rhs: BuildEventStream_BuildEventId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnknownBuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnknownBuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.details)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnknownBuildEventId, rhs: BuildEventStream_BuildEventId.UnknownBuildEventId) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ProgressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ProgressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opaque_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.opaqueCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.opaqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.opaqueCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ProgressId, rhs: BuildEventStream_BuildEventId.ProgressId) -> Bool {
    if lhs.opaqueCount != rhs.opaqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildStartedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildStartedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildStartedId, rhs: BuildEventStream_BuildEventId.BuildStartedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnstructuredCommandLineId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId, rhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.StructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".StructuredCommandLineId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.commandLineLabel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLineLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLineLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.StructuredCommandLineId, rhs: BuildEventStream_BuildEventId.StructuredCommandLineId) -> Bool {
    if lhs.commandLineLabel != rhs.commandLineLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceStatusId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceStatusId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceStatusId, rhs: BuildEventStream_BuildEventId.WorkspaceStatusId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.OptionsParsedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".OptionsParsedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.OptionsParsedId, rhs: BuildEventStream_BuildEventId.OptionsParsedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.FetchId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".FetchId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.FetchId, rhs: BuildEventStream_BuildEventId.FetchId) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.PatternExpandedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".PatternExpandedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.pattern)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.PatternExpandedId, rhs: BuildEventStream_BuildEventId.PatternExpandedId) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetConfiguredId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetConfiguredId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2: try decoder.decodeSingularStringField(value: &self.aspect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetConfiguredId, rhs: BuildEventStream_BuildEventId.TargetConfiguredId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.NamedSetOfFilesId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".NamedSetOfFilesId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.NamedSetOfFilesId, rhs: BuildEventStream_BuildEventId.NamedSetOfFilesId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfigurationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfigurationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfigurationId, rhs: BuildEventStream_BuildEventId.ConfigurationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    3: .same(proto: "configuration"),
    2: .same(proto: "aspect"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _aspect: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _aspect = source._aspect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularStringField(value: &_storage._aspect)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if !_storage._aspect.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aspect, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetCompletedId, rhs: BuildEventStream_BuildEventId.TargetCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._aspect != rhs_storage._aspect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ActionCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ActionCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_output"),
    2: .same(proto: "label"),
    3: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _primaryOutput: String = String()
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _primaryOutput = source._primaryOutput
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._primaryOutput)
        case 2: try decoder.decodeSingularStringField(value: &_storage._label)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._primaryOutput.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryOutput, fieldNumber: 1)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ActionCompletedId, rhs: BuildEventStream_BuildEventId.ActionCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnconfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnconfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnconfiguredLabelId, rhs: BuildEventStream_BuildEventId.UnconfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfiguredLabelId, rhs: BuildEventStream_BuildEventId.ConfiguredLabelId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestResultId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestResultId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    5: .same(proto: "configuration"),
    2: .same(proto: "run"),
    3: .same(proto: "shard"),
    4: .same(proto: "attempt"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _run: Int32 = 0
    var _shard: Int32 = 0
    var _attempt: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _run = source._run
      _shard = source._shard
      _attempt = source._attempt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._run)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._shard)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._attempt)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if _storage._run != 0 {
        try visitor.visitSingularInt32Field(value: _storage._run, fieldNumber: 2)
      }
      if _storage._shard != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shard, fieldNumber: 3)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 4)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestResultId, rhs: BuildEventStream_BuildEventId.TestResultId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._run != rhs_storage._run {return false}
        if _storage._shard != rhs_storage._shard {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestSummaryId, rhs: BuildEventStream_BuildEventId.TestSummaryId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildFinishedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildFinishedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildFinishedId, rhs: BuildEventStream_BuildEventId.BuildFinishedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildToolLogsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildToolLogsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildToolLogsId, rhs: BuildEventStream_BuildEventId.BuildToolLogsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetricsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetricsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetricsId, rhs: BuildEventStream_BuildEventId.BuildMetricsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.stdout)
      case 2: try decoder.decodeSingularStringField(value: &self.stderr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularStringField(value: self.stderr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Progress, rhs: BuildEventStream_Progress) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aborted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Aborted, rhs: BuildEventStream_Aborted) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted.AbortReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER_INTERRUPTED"),
    2: .same(proto: "TIME_OUT"),
    3: .same(proto: "REMOTE_ENVIRONMENT_FAILURE"),
    4: .same(proto: "INTERNAL"),
    5: .same(proto: "LOADING_FAILURE"),
    6: .same(proto: "ANALYSIS_FAILURE"),
    7: .same(proto: "SKIPPED"),
    8: .same(proto: "NO_ANALYZE"),
    9: .same(proto: "NO_BUILD"),
  ]
}

extension BuildEventStream_BuildStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStarted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "start_time_millis"),
    3: .standard(proto: "build_tool_version"),
    4: .standard(proto: "options_description"),
    5: .same(proto: "command"),
    6: .standard(proto: "working_directory"),
    7: .standard(proto: "workspace_directory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uuid)
      case 2: try decoder.decodeSingularInt64Field(value: &self.startTimeMillis)
      case 3: try decoder.decodeSingularStringField(value: &self.buildToolVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.optionsDescription)
      case 5: try decoder.decodeSingularStringField(value: &self.command)
      case 6: try decoder.decodeSingularStringField(value: &self.workingDirectory)
      case 7: try decoder.decodeSingularStringField(value: &self.workspaceDirectory)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.startTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMillis, fieldNumber: 2)
    }
    if !self.buildToolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.buildToolVersion, fieldNumber: 3)
    }
    if !self.optionsDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionsDescription, fieldNumber: 4)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.workspaceDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDirectory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildStarted, rhs: BuildEventStream_BuildStarted) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.startTimeMillis != rhs.startTimeMillis {return false}
    if lhs.buildToolVersion != rhs.buildToolVersion {return false}
    if lhs.optionsDescription != rhs.optionsDescription {return false}
    if lhs.command != rhs.command {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.workspaceDirectory != rhs.workspaceDirectory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_UnstructuredCommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnstructuredCommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.args)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_UnstructuredCommandLine, rhs: BuildEventStream_UnstructuredCommandLine) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OptionsParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionsParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "startup_options"),
    2: .standard(proto: "explicit_startup_options"),
    3: .standard(proto: "cmd_line"),
    4: .standard(proto: "explicit_cmd_line"),
    5: .standard(proto: "invocation_policy"),
    6: .standard(proto: "tool_tag"),
  ]

  fileprivate class _StorageClass {
    var _startupOptions: [String] = []
    var _explicitStartupOptions: [String] = []
    var _cmdLine: [String] = []
    var _explicitCmdLine: [String] = []
    var _invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy? = nil
    var _toolTag: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startupOptions = source._startupOptions
      _explicitStartupOptions = source._explicitStartupOptions
      _cmdLine = source._cmdLine
      _explicitCmdLine = source._explicitCmdLine
      _invocationPolicy = source._invocationPolicy
      _toolTag = source._toolTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._startupOptions)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._explicitStartupOptions)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._cmdLine)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._explicitCmdLine)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._invocationPolicy)
        case 6: try decoder.decodeSingularStringField(value: &_storage._toolTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._startupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._startupOptions, fieldNumber: 1)
      }
      if !_storage._explicitStartupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitStartupOptions, fieldNumber: 2)
      }
      if !_storage._cmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cmdLine, fieldNumber: 3)
      }
      if !_storage._explicitCmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitCmdLine, fieldNumber: 4)
      }
      if let v = _storage._invocationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._toolTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toolTag, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OptionsParsed, rhs: BuildEventStream_OptionsParsed) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startupOptions != rhs_storage._startupOptions {return false}
        if _storage._explicitStartupOptions != rhs_storage._explicitStartupOptions {return false}
        if _storage._cmdLine != rhs_storage._cmdLine {return false}
        if _storage._explicitCmdLine != rhs_storage._explicitCmdLine {return false}
        if _storage._invocationPolicy != rhs_storage._invocationPolicy {return false}
        if _storage._toolTag != rhs_storage._toolTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fetch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Fetch, rhs: BuildEventStream_Fetch) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.item)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus, rhs: BuildEventStream_WorkspaceStatus) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_WorkspaceStatus.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus.Item, rhs: BuildEventStream_WorkspaceStatus.Item) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "platform_name"),
    3: .same(proto: "cpu"),
    4: .standard(proto: "make_variable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.mnemonic)
      case 2: try decoder.decodeSingularStringField(value: &self.platformName)
      case 3: try decoder.decodeSingularStringField(value: &self.cpu)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.makeVariable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 2)
    }
    if !self.cpu.isEmpty {
      try visitor.visitSingularStringField(value: self.cpu, fieldNumber: 3)
    }
    if !self.makeVariable.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.makeVariable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Configuration, rhs: BuildEventStream_Configuration) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.cpu != rhs.cpu {return false}
    if lhs.makeVariable != rhs.makeVariable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternExpanded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded, rhs: BuildEventStream_PatternExpanded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetConfigured"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_kind"),
    2: .standard(proto: "test_size"),
    3: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.targetKind)
      case 2: try decoder.decodeSingularEnumField(value: &self.testSize)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tag)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 1)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetConfigured, rhs: BuildEventStream_TargetConfigured) -> Bool {
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.file = .uri(v)}
      case 3:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.file = .contents(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.file {
    case .uri(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .contents(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_File, rhs: BuildEventStream_File) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_NamedSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.files)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_NamedSetOfFiles, rhs: BuildEventStream_NamedSetOfFiles) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ActionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionExecuted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    8: .same(proto: "type"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "stdout"),
    4: .same(proto: "stderr"),
    5: .same(proto: "label"),
    7: .same(proto: "configuration"),
    6: .standard(proto: "primary_output"),
    9: .standard(proto: "command_line"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _type: String = String()
    var _exitCode: Int32 = 0
    var _stdout: BuildEventStream_File? = nil
    var _stderr: BuildEventStream_File? = nil
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _primaryOutput: BuildEventStream_File? = nil
    var _commandLine: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _type = source._type
      _exitCode = source._exitCode
      _stdout = source._stdout
      _stderr = source._stderr
      _label = source._label
      _configuration = source._configuration
      _primaryOutput = source._primaryOutput
      _commandLine = source._commandLine
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._success)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._stdout)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._stderr)
        case 5: try decoder.decodeSingularStringField(value: &_storage._label)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._primaryOutput)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        case 8: try decoder.decodeSingularStringField(value: &_storage._type)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._commandLine)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 2)
      }
      if let v = _storage._stdout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._stderr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      if let v = _storage._primaryOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._commandLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandLine, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ActionExecuted, rhs: BuildEventStream_ActionExecuted) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._stdout != rhs_storage._stdout {return false}
        if _storage._stderr != rhs_storage._stderr {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._commandLine != rhs_storage._commandLine {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OutputGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OutputGroup, rhs: BuildEventStream_OutputGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    5: .standard(proto: "target_kind"),
    6: .standard(proto: "test_size"),
    2: .standard(proto: "output_group"),
    4: .standard(proto: "important_output"),
    3: .same(proto: "tag"),
    7: .standard(proto: "test_timeout_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.outputGroup)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tag)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.importantOutput)
      case 5: try decoder.decodeSingularStringField(value: &self.targetKind)
      case 6: try decoder.decodeSingularEnumField(value: &self.testSize)
      case 7: try decoder.decodeSingularInt64Field(value: &self.testTimeoutSeconds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.outputGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputGroup, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    if !self.importantOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importantOutput, fieldNumber: 4)
    }
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 5)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 6)
    }
    if self.testTimeoutSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.testTimeoutSeconds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetComplete, rhs: BuildEventStream_TargetComplete) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.outputGroup != rhs.outputGroup {return false}
    if lhs.importantOutput != rhs.importantOutput {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.testTimeoutSeconds != rhs.testTimeoutSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "status"),
    9: .standard(proto: "status_details"),
    4: .standard(proto: "cached_locally"),
    6: .standard(proto: "test_attempt_start_millis_epoch"),
    3: .standard(proto: "test_attempt_duration_millis"),
    2: .standard(proto: "test_action_output"),
    7: .same(proto: "warning"),
    8: .standard(proto: "execution_info"),
  ]

  fileprivate class _StorageClass {
    var _status: BuildEventStream_TestStatus = .noStatus
    var _statusDetails: String = String()
    var _cachedLocally: Bool = false
    var _testAttemptStartMillisEpoch: Int64 = 0
    var _testAttemptDurationMillis: Int64 = 0
    var _testActionOutput: [BuildEventStream_File] = []
    var _warning: [String] = []
    var _executionInfo: BuildEventStream_TestResult.ExecutionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _statusDetails = source._statusDetails
      _cachedLocally = source._cachedLocally
      _testAttemptStartMillisEpoch = source._testAttemptStartMillisEpoch
      _testAttemptDurationMillis = source._testAttemptDurationMillis
      _testActionOutput = source._testActionOutput
      _warning = source._warning
      _executionInfo = source._executionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._testActionOutput)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptDurationMillis)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._cachedLocally)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptStartMillisEpoch)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._warning)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._executionInfo)
        case 9: try decoder.decodeSingularStringField(value: &_storage._statusDetails)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._testActionOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testActionOutput, fieldNumber: 2)
      }
      if _storage._testAttemptDurationMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptDurationMillis, fieldNumber: 3)
      }
      if _storage._cachedLocally != false {
        try visitor.visitSingularBoolField(value: _storage._cachedLocally, fieldNumber: 4)
      }
      if _storage._status != .noStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._testAttemptStartMillisEpoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptStartMillisEpoch, fieldNumber: 6)
      }
      if !_storage._warning.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._warning, fieldNumber: 7)
      }
      if let v = _storage._executionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._statusDetails.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusDetails, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult, rhs: BuildEventStream_TestResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusDetails != rhs_storage._statusDetails {return false}
        if _storage._cachedLocally != rhs_storage._cachedLocally {return false}
        if _storage._testAttemptStartMillisEpoch != rhs_storage._testAttemptStartMillisEpoch {return false}
        if _storage._testAttemptDurationMillis != rhs_storage._testAttemptDurationMillis {return false}
        if _storage._testActionOutput != rhs_storage._testActionOutput {return false}
        if _storage._warning != rhs_storage._warning {return false}
        if _storage._executionInfo != rhs_storage._executionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.protoMessageName + ".ExecutionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_seconds"),
    2: .same(proto: "strategy"),
    6: .standard(proto: "cached_remotely"),
    7: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "timing_breakdown"),
    5: .standard(proto: "resource_usage"),
  ]

  fileprivate class _StorageClass {
    var _timeoutSeconds: Int32 = 0
    var _strategy: String = String()
    var _cachedRemotely: Bool = false
    var _exitCode: Int32 = 0
    var _hostname: String = String()
    var _timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown? = nil
    var _resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeoutSeconds = source._timeoutSeconds
      _strategy = source._strategy
      _cachedRemotely = source._cachedRemotely
      _exitCode = source._exitCode
      _hostname = source._hostname
      _timingBreakdown = source._timingBreakdown
      _resourceUsage = source._resourceUsage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 2: try decoder.decodeSingularStringField(value: &_storage._strategy)
        case 3: try decoder.decodeSingularStringField(value: &_storage._hostname)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._timingBreakdown)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._resourceUsage)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._cachedRemotely)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timeoutSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeoutSeconds, fieldNumber: 1)
      }
      if !_storage._strategy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._strategy, fieldNumber: 2)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 3)
      }
      if let v = _storage._timingBreakdown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._resourceUsage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resourceUsage, fieldNumber: 5)
      }
      if _storage._cachedRemotely != false {
        try visitor.visitSingularBoolField(value: _storage._cachedRemotely, fieldNumber: 6)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo, rhs: BuildEventStream_TestResult.ExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._cachedRemotely != rhs_storage._cachedRemotely {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._timingBreakdown != rhs_storage._timingBreakdown {return false}
        if _storage._resourceUsage != rhs_storage._resourceUsage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".TimingBreakdown"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "name"),
    3: .standard(proto: "time_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.child)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timeMillis)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.timeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.timeMillis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown, rhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.name != rhs.name {return false}
    if lhs.timeMillis != rhs.timeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage, rhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "overall_status"),
    1: .standard(proto: "total_run_count"),
    3: .same(proto: "passed"),
    4: .same(proto: "failed"),
    6: .standard(proto: "total_num_cached"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.totalRunCount)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.passed)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.failed)
      case 5: try decoder.decodeSingularEnumField(value: &self.overallStatus)
      case 6: try decoder.decodeSingularInt32Field(value: &self.totalNumCached)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalRunCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRunCount, fieldNumber: 1)
    }
    if !self.passed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passed, fieldNumber: 3)
    }
    if !self.failed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failed, fieldNumber: 4)
    }
    if self.overallStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallStatus, fieldNumber: 5)
    }
    if self.totalNumCached != 0 {
      try visitor.visitSingularInt32Field(value: self.totalNumCached, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestSummary, rhs: BuildEventStream_TestSummary) -> Bool {
    if lhs.overallStatus != rhs.overallStatus {return false}
    if lhs.totalRunCount != rhs.totalRunCount {return false}
    if lhs.passed != rhs.passed {return false}
    if lhs.failed != rhs.failed {return false}
    if lhs.totalNumCached != rhs.totalNumCached {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_success"),
    3: .standard(proto: "exit_code"),
    2: .standard(proto: "finish_time_millis"),
  ]

  fileprivate class _StorageClass {
    var _overallSuccess: Bool = false
    var _exitCode: BuildEventStream_BuildFinished.ExitCode? = nil
    var _finishTimeMillis: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _overallSuccess = source._overallSuccess
      _exitCode = source._exitCode
      _finishTimeMillis = source._finishTimeMillis
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._overallSuccess)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._finishTimeMillis)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._exitCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._overallSuccess != false {
        try visitor.visitSingularBoolField(value: _storage._overallSuccess, fieldNumber: 1)
      }
      if _storage._finishTimeMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._finishTimeMillis, fieldNumber: 2)
      }
      if let v = _storage._exitCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished, rhs: BuildEventStream_BuildFinished) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._overallSuccess != rhs_storage._overallSuccess {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._finishTimeMillis != rhs_storage._finishTimeMillis {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.ExitCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".ExitCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt32Field(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.ExitCode, rhs: BuildEventStream_BuildFinished.ExitCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_summary"),
    2: .standard(proto: "memory_metrics"),
  ]

  fileprivate class _StorageClass {
    var _actionSummary: BuildEventStream_BuildMetrics.ActionSummary? = nil
    var _memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actionSummary = source._actionSummary
      _memoryMetrics = source._memoryMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._actionSummary)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._memoryMetrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._actionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._memoryMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics, rhs: BuildEventStream_BuildMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionSummary != rhs_storage._actionSummary {return false}
        if _storage._memoryMetrics != rhs_storage._memoryMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actions_created"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.actionsCreated)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsCreated != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary, rhs: BuildEventStream_BuildMetrics.ActionSummary) -> Bool {
    if lhs.actionsCreated != rhs.actionsCreated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".MemoryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_heap_size_post_build"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.usedHeapSizePostBuild)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedHeapSizePostBuild != 0 {
      try visitor.visitSingularInt64Field(value: self.usedHeapSizePostBuild, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics) -> Bool {
    if lhs.usedHeapSizePostBuild != rhs.usedHeapSizePostBuild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildToolLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildToolLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.log)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildToolLogs, rhs: BuildEventStream_BuildToolLogs) -> Bool {
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "children"),
    20: .standard(proto: "last_message"),
    3: .same(proto: "progress"),
    4: .same(proto: "aborted"),
    5: .same(proto: "started"),
    12: .standard(proto: "unstructured_command_line"),
    22: .standard(proto: "structured_command_line"),
    13: .standard(proto: "options_parsed"),
    16: .standard(proto: "workspace_status"),
    21: .same(proto: "fetch"),
    17: .same(proto: "configuration"),
    6: .same(proto: "expanded"),
    18: .same(proto: "configured"),
    7: .same(proto: "action"),
    15: .standard(proto: "named_set_of_files"),
    8: .same(proto: "completed"),
    10: .standard(proto: "test_result"),
    9: .standard(proto: "test_summary"),
    14: .same(proto: "finished"),
    23: .standard(proto: "build_tool_logs"),
    24: .standard(proto: "build_metrics"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId? = nil
    var _children: [BuildEventStream_BuildEventId] = []
    var _lastMessage: Bool = false
    var _payload: BuildEventStream_BuildEvent.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _children = source._children
      _lastMessage = source._lastMessage
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._children)
        case 3:
          var v: BuildEventStream_Progress?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .progress(v)}
        case 4:
          var v: BuildEventStream_Aborted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .aborted(v)}
        case 5:
          var v: BuildEventStream_BuildStarted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .started(v)}
        case 6:
          var v: BuildEventStream_PatternExpanded?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .expanded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .expanded(v)}
        case 7:
          var v: BuildEventStream_ActionExecuted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .action(v)}
        case 8:
          var v: BuildEventStream_TargetComplete?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .completed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .completed(v)}
        case 9:
          var v: BuildEventStream_TestSummary?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testSummary(v)}
        case 10:
          var v: BuildEventStream_TestResult?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testResult(v)}
        case 12:
          var v: BuildEventStream_UnstructuredCommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .unstructuredCommandLine(v)}
        case 13:
          var v: BuildEventStream_OptionsParsed?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .optionsParsed(v)}
        case 14:
          var v: BuildEventStream_BuildFinished?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .finished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .finished(v)}
        case 15:
          var v: BuildEventStream_NamedSetOfFiles?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .namedSetOfFiles(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .namedSetOfFiles(v)}
        case 16:
          var v: BuildEventStream_WorkspaceStatus?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .workspaceStatus(v)}
        case 17:
          var v: BuildEventStream_Configuration?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configuration(v)}
        case 18:
          var v: BuildEventStream_TargetConfigured?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configured(v)}
        case 20: try decoder.decodeSingularBoolField(value: &_storage._lastMessage)
        case 21:
          var v: BuildEventStream_Fetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .fetch(v)}
        case 22:
          var v: CommandLine_CommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .structuredCommandLine(v)}
        case 23:
          var v: BuildEventStream_BuildToolLogs?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildToolLogs(v)}
        case 24:
          var v: BuildEventStream_BuildMetrics?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildMetrics(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 2)
      }
      switch _storage._payload {
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .aborted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .expanded(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .action(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .completed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .finished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .namedSetOfFiles(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .configured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case nil: break
      default: break
      }
      if _storage._lastMessage != false {
        try visitor.visitSingularBoolField(value: _storage._lastMessage, fieldNumber: 20)
      }
      switch _storage._payload {
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEvent, rhs: BuildEventStream_BuildEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
